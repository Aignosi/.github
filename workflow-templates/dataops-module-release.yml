name: DataOps Module Release

on:
  workflow_call:
    inputs:
      project_name:
        required: true
        type: string
        description: 'Name of the project/module to release (e.g., ingestor, processor, etc.)'
      python_version:
        required: false
        type: string
        default: '3.11'
        description: 'Python version to use for the release process'
      release_prefix:
        required: false
        type: string
        default: 'sientia'
        description: 'Prefix for the release package name'
      encrypt_script:
        required: false
        type: string
        default: 'encrypt.py'
        description: 'Name of the encryption script to use'
      ignore_file:
        required: false
        type: string
        default: '.gitignore'
        description: 'File containing patterns to ignore during encryption'
      chunk_size:
        required: false
        type: string
        default: '100000'
        description: 'Chunk size for encryption process'

jobs:
  create-release:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      pull-requests: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '${{ inputs.python_version }}'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml pathspec

      - name: Get branch name
        id: branch_name
        run: |
          # Obtém o nome da branch da PR
          BRANCH_NAME=${GITHUB_HEAD_REF}
          echo "Branch da PR: $BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Determine next version
        id: next_version
        run: |
          BRANCH_NAME=${{ steps.branch_name.outputs.branch_name }}

          # Baixa todas as tags
          git fetch --tags

          # Pega a última tag sem filtro
          LAST_TAG=$(git tag --sort=-v:refname | head -n1)
          echo "Última tag encontrada: $LAST_TAG"

          # Se não houver tags, assume 0.0.0
          if [ -z "$LAST_TAG" ]; then
            LAST_TAG="0.0.0"
          fi

          # Extrai major, minor, patch
          IFS='.' read -r MAJOR MINOR PATCH <<< "$LAST_TAG"

          echo "Versão atual: $MAJOR.$MINOR.$PATCH"

          # Incrementa conforme tipo de branch
          if [[ "$BRANCH_NAME" == release/* ]]; then
            NEW_MAJOR=$((MAJOR + 1))
            NEW_MINOR=0
            NEW_PATCH=0
          elif [[ "$BRANCH_NAME" == feature/* ]]; then
            NEW_MAJOR=$MAJOR
            NEW_MINOR=$((MINOR + 1))
            NEW_PATCH=0
          elif [[ "$BRANCH_NAME" == fix/* ]]; then
            NEW_MAJOR=$MAJOR
            NEW_MINOR=$MINOR
            NEW_PATCH=$((PATCH + 1))
          else
            echo "Tipo de branch desconhecido. Abortando."
            exit 1
          fi

          NEXT_VERSION="${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}"
          echo "Nova versão calculada: $NEXT_VERSION"

          echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT

      - name: Generate encrypted code
        id: encrypt_code
        run: |
          VERSION="${{ steps.next_version.outputs.version }}"
          OUTPUT_DIR="encrypted_release"
          
          # Create output directory
          mkdir -p $OUTPUT_DIR
          
          # Run encrypt.py script
          python ${{ inputs.encrypt_script }} . encrypted_code --ignore ${{ inputs.ignore_file }} --chunk-size ${{ inputs.chunk_size }}
          
          # Move generated files to output directory
          mv encrypted_code_*.yaml $OUTPUT_DIR/ 2>/dev/null || true
          
          # Create a zip file with the encrypted files
          zip -r "${{ inputs.release_prefix }}-${{ inputs.project_name }}-${VERSION}-encrypted.zip" $OUTPUT_DIR/
          
          echo "encrypted_zip=${{ inputs.release_prefix }}-${{ inputs.project_name }}-${VERSION}-encrypted.zip" >> $GITHUB_OUTPUT
          echo "encrypted_dir=$OUTPUT_DIR" >> $GITHUB_OUTPUT

      - name: Create GitHub Release via API
        uses: actions/github-script@v7
        with:
          script: |
            const { repo, owner } = context.repo;
            const version = "${{ steps.next_version.outputs.version }}";
            const branch = "main";
            const encryptedZip = "${{ steps.encrypt_code.outputs.encrypted_zip }}";

            console.log(`Criando release para a tag: ${version} a partir da branch ${branch}`);
            console.log(`Arquivo zip criptografado: ${encryptedZip}`);

            // Read the encrypted zip file
            const fs = require('fs');
            const zipContent = fs.readFileSync(encryptedZip);

            const response = await github.rest.repos.createRelease({
              owner,
              repo,
              tag_name: version,
              name: `${version}`,
              target_commitish: branch,
              generate_release_notes: true
            });

            // Upload the encrypted zip as an asset
            await github.rest.repos.uploadReleaseAsset({
              owner,
              repo,
              release_id: response.data.id,
              name: encryptedZip,
              data: zipContent,
              headers: {
                'content-type': 'application/zip'
              }
            });

            console.log(`Release criada com sucesso! URL: ${response.data.html_url}`);
            console.log(`Arquivo criptografado anexado: ${encryptedZip}`);
